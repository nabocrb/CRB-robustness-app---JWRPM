---
title: "CRB robustness tradeoffs"
output: 
  flexdashboard::flex_dashboard:
    source_code: "https://github.com/nabocrb/CRB-robustness-app---JWRPM"
    theme: spacelab
    
runtime: shiny
---




```{r, setup, include=FALSE}

######################## load packages and user defined functions #############
source("Function library.R", local=TRUE) # must include local=TRUE. See here: https://shiny.rstudio.com/articles/scoping.html

function_df=reactiveValues() # need to initialize the dataframes used in the manual and brush filter functions
manual_log=reactiveValues()  # initialize the log

######################## import robustness metrics data ############################

# this includes the non dominated front. Calculated externally to save app loading time
metrics_4app_n500=readRDS('tradeoff_dataframes.rds')
metrics_4app_n300=readRDS("tradeoff_dataframes_300SOW.rds")

# used for x axis in stacked histogram plot
metrics.list_n500=readRDS('Robustness_metrics_463solns_List.rds')
metrics.list_n300=readRDS('Robustness_metrics_463solns_List_300SOW.rds')

metrics.list_n500[['optimization']]=metrics_4app_n500$optimization
metrics.list_n300[['optimization']]=metrics_4app_n300$optimization


################### import data for stacked histogram plotting ##########################

bar_plot_data=readRDS(file='data for stacked bar plot.rds')
long_data=bar_plot_data$long_data
wide_data=bar_plot_data$wide_data
wide_data$ID=1:nrow(wide_data)

add_to_tradeoff_all=wide_data[4:8] # T1e, T1V, maxVol, nTiers to add to each df for filtering
add_to_tradeoff=dplyr::filter(add_to_tradeoff_all, ID %in% metrics.list_n500$satisficing$ID)[-ncol(add_to_tradeoff_all)]# minus five to remove ID

############## import DV so user can add to custom parallel coordinates #########
DV_prep=read.table('Archive_463_Condensed.txt')

DV=data.frame(ID=wide_data$ID, DV_prep, ntiers=add_to_tradeoff$nTiers, maxVol=add_to_tradeoff$maxVol)
metrics.list_n500[["decision variables"]]=DV
metrics.list_n300[["decision variables"]]=DV
metrics_4app_n500[["decision variables"]]=DV
metrics_4app_n300[["decision variables"]]=DV

############# turn robustness lists into reactive values so user can switch SOW ensemble ###########
metrics_4app=reactiveValues(l=metrics_4app_n500) # initialize app with n500 SOW ensemble
metrics.list=reactiveValues(l=metrics.list_n500)# initialize app with n500 SOW ensemble

observeEvent(input$SOWensemble, {
  
  if (input$SOWensemble=='cLHS n500'){
    metrics_4app$l=metrics_4app_n500
    metrics.list$l=metrics.list_n500
  } else if (input$SOWensemble=="cLHS n300") {
    metrics_4app$l=metrics_4app_n300
    metrics.list$l=metrics.list_n300
  } else {
    metrics_4app$l=metrics_4app_n500
    metrics.list$l=metrics.list_n500

  }
  
  
  
})


# scale mean_variance between 0 and 1

observe({

  colID=which(!(colnames(metrics_4app$l[['mean.variance']]) %in% c('ID', 'front')))

  for(i in colID){ # start in column three to skip ID and front
   max=max(metrics_4app$l$mean.variance[,i])
    replace=metrics_4app$l$mean.variance[,i]/max
  
    metrics_4app$l$mean.variance[,i]=replace
  }
})

###################### prepare robustness data frames ##################
########################################################################

global_filter=reactiveValues(r=1:463) # Initiate with all policies. changes whenever a user hits save button.
in_global_filter=reactiveValues(y=rep(1,nrow(wide_data)))

observe({ # create matrix of constraint ranges for PC ID axis
  a=global_filter$r-.001
  b=global_filter$r+.001
  global_filter$constraints=matrix(c(a,b),ncol=2, byrow = FALSE)})

# create prep dataframes, reactive to user changing SOW ensemble

prep=reactiveValues()


observe({
  
###### optimization objectives (in MOEA optimization)
prep$optimization=data.frame(metrics_4app$l$optimization, add_to_tradeoff)

###### LBSV < 600 KAF, Mead 1000 < 10% and Powell 3490 < 5%#####
prep$satisficing=data.frame(metrics_4app$l$satisficing, add_to_tradeoff)

##### % deviation
prep$percent_deviation=data.frame(metrics_4app$l$percent.deviation, add_to_tradeoff)

#### tradeoff between mean of objectives (Laplace PIR)
prep$mean=data.frame(metrics_4app$l$mean, add_to_tradeoff)

#### tradeoff between mean-variance

prep$mean_var=data.frame(metrics_4app$l$mean.variance, add_to_tradeoff)

### regret from best tradeoffs
prep$regret2=data.frame(metrics_4app$l$regret.from.best, add_to_tradeoff)

#### tradeoffs between Hurwicz OP
prep$Hurwicz=data.frame(metrics_4app$l$Hurwicz.OP, add_to_tradeoff)

#### maximin (worst case SOW) tradeoffs
prep$maximin=data.frame(metrics_4app$l$maximin, add_to_tradeoff)

})

optimization=reactiveValues()

observe({
  
  optimization$all=prep$optimization
  optimization$g=dplyr::filter(prep$optimization, ID %in% global_filter$r)
  
})

###### update prep and optimization reactive values if user selects a subset with Kennard Stone #########

KS=reactiveValues(index=1:463) # preallocate KS index

observeEvent(input$KSApply,{ # Get KS index when user hits apply button in settings page
  
  req(isTruthy(input$KSmetric))  
  
  if (input$KSmetric=="Decision Variables") { # get ID ID from KenStone.samples
    temp=data.frame(ID=1:nrow(wide_data), DV_prep)
    data=dplyr::filter(temp, ID %in% global_filter$r) # input data is DV of policies in global filter
    tempi=kenStone(X=scale(data[-1]), k=input$KSnSample)$model # get row indices of Ken Stone samples from DV data. By subsetting temp to global filter policies, you are sampling from policies contained in global filters only
    KS$index=data[["ID"]][tempi] # convert row indices to ID ID. save in KS$index
    
  } else { # optimization performance
    # KS$index=KenStone.samples$optimization[1:input$KSnSample]
    tempi=kenStone(X=scale(filter.optimization()[2:9]), k=input$KSnSample)$model # get row indices of Ken Stone samples from filter.optimization(). By using filter.optimization() as data, you are sampling from policies contained in intersection of global filters and local optimization filters.
    KS$index=filter.optimization()[["ID"]][tempi] # convert row indices to ID ID. save in KS$index
   
    
  }
  
  # if KenStone is used on all policies, the algorithm returns all but one ID. Easiest correction is to check for this circumstance than override KS$index to include all policies
    if (input$KSnSample == nrow(wide_data)){
      KS$index=1:nrow(wide_data)
    }
  
  
  if (nrow(prep[["optimization"]]) < input$KSnSample){ # if user tries to INCREASE the number of KS samples
    showNotification("# of samples > # of policies. Resetting polices to global filter.", type="warning", duration=7)
    
    prep$optimization=data.frame(metrics_4app$l$optimization, add_to_tradeoff)
    prep$satisficing=data.frame(metrics_4app$l$satisficing, add_to_tradeoff)
    prep$percent_deviation=data.frame(metrics_4app$l$percent.deviation, add_to_tradeoff)
    prep$mean=data.frame(metrics_4app$l$mean, add_to_tradeoff)
    prep$mean_var=data.frame(metrics_4app$l$mean.variance, add_to_tradeoff)
    prep$regret2=data.frame(metrics_4app$l$regret.from.best, add_to_tradeoff)
    prep$Hurwicz=data.frame(metrics_4app$l$Hurwicz.OP, add_to_tradeoff)
    prep$maximin=data.frame(metrics_4app$l$maximin, add_to_tradeoff)
    
  }
  
  
  for (name in names(prep)){ # subset the prep dfs by KSindex
    prep[[name]]=dplyr::filter(prep[[name]], ID %in% KS$index)
  }

  
  
}, ignoreInit = F, ignoreNULL = F)

# need to subset all prep df again if user recalculates satisficing or Hurwicz

observeEvent(satisdf$trigger > 0 | Hurwicdf$trigger > 0, {
  
  for (name in names(prep)){ # subset the prep dfs by KSindex
    prep[[name]]=dplyr::filter(prep[[name]], ID %in% KS$index)
  }
  
  satisdf$trigger=0
  Hurwicdf$trigger=0
})

###### prepare reactiveValue global filters log object ######

df.initialize=data.frame(matrix(ncol=6, nrow=1), stringsAsFactors = FALSE)
colnames(df.initialize)=c("page", "metric", "filter.type", "lower", "upper", "table.selection.ID")

filterLog=reactiveValues(global=df.initialize, local=df.initialize)


```

```{r, satisficing calcs data}
obj_all=read.table('objectives_all463.txt') # load data for calculating robustness

vol_index=which(colnames(obj_all) %in% c('LB.Shortage.Volume',"LB.Shortage.Volume.Policy", "Max.Annual.LB.Shortage"))
obj_all[,vol_index]=obj_all[,vol_index]/1000 # convert to KAF
obj_all[["Powell.WY.Release"]]=obj_all[["Powell.WY.Release"]]/(10^6) # convert to MAF

colnames(obj_all)=c('TraceNumber', 'policy', 'LB.Avg', 'LB.Avg.Policy', 'LF.Deficit', 'M1000', 'P3490', 'LB.Dur', 'LB.Freq', 'LB.Max', 'P.WYR')
my_order=c('LF.Deficit', 'P.WYR', 'P3490', 'M1000', 'LB.Avg', 'LB.Freq', 'LB.Max', 'LB.Dur')
obj_all=obj_all[c('TraceNumber', 'policy', my_order)]

SOW_500_300_100=readRDS("SOW ensemble 500_300_100.rds") # list of SOW ensembles
SOW_id=sort(SOW_500_300_100[[2]]$model) # SOW IDs of the 300 member SOW ensemble

```


```{r, settings Modal}

bsModal(id="modalSettings" ,title= "global plot settings", trigger="settingsOptimization",

h3("Parallel coordinates plot options"),        
hr(), # add a line
h5('Color scale'),
selectInput("ColorScale", label=NULL, selected='blue-red', choices=c('blue-red', 'Viridis','Picnic', 'Rainbow', 'Portland', 'Blackbody', 'Cividis', "YlGnBu", "Jet", "Hot", "Earth")),
bsTooltip(id="ColorScale", title="change the color gradient used in the parallel coordinates plot", placement = "right", options=list(container="body") ),
# bsPopover(id="ColorScale", title="test", content="change the color gradient used in the parallel coordinates plot")

h5('Reverse color scale?'),
prettyToggle("ReverseTF", label_on='   Yes   ', label_off='No', value=FALSE, width = '200px', bigger = T),
bsTooltip(id="ReverseTF", title="reverse the direction of parallel coordinates color scale. e.g: change blue-red to red-blue", placement = "right", options=list(container="body")),

h5('Keep or Remove policies?'),
prettyToggle("KeepPoliciesTF", label_on='Keep', label_off='Remove', value=FALSE, width = '200px', bigger=TRUE),
bsTooltip(id="KeepPoliciesTF", title="Should policies be removed from the parallel coordinates plot when they are filtered out? Note that policies are always removed from the decision variable plot. WARNING: When set to KEEP, policies removed from the global filter are shown in transparent gray in the parallel coordinates plot. Clicking on the ID axis will cause all policies to be shown in color.", placement = "right", options=list(container="body")),

h5("Maintain axes ranges of all policies?"),
prettyToggle("MaintainAxes", label_on = "Yes", label_off="No", value=TRUE, width="200px", bigger = TRUE),
bsTooltip(id="MaintainAxes", title="Should the axes in parallel coordinates plots use the maximum ranges from all 463 policies, or should the range shrink as policies are removed?", placement = "right", options=list(container="body")),

h5("Show or hide ID and front axes?"),
prettyToggle(inputId = "ShowID_Front", label_on = "Show", label_off = "Hide", value = TRUE, width="200px", bigger = TRUE),
bsTooltip(id="ShowID_Front", title = "Should the ID and front axes in the parallel coordinates plot be shown? Hiding these axes is useful for visualizing Pareto-dominance. CAUTION: when set to Hide, table selections are disabled, and -Keep or Remove policies from par coords- is ineffective when set to Keep.", placement = "right", options=list(container="body")), 

h4("label options"),
sliderInput(inputId = "titlesize", label= "Title font size", min=1, max=30, value=24),
sliderInput(inputId = "labelsize", label = "Label font size", min=1, max=30, value=13),
sliderInput(inputId = "labelangle",label = "Axes label angle from horizontal", min=-90, max=90, value=-10),

splitLayout(cellWidths = c(220,20),h4("image download options"), circleButton(inputId = "imageHelp", icon=icon("info-circle"), size = "xs")),

bsTooltip(id="imageHelp", title = "Set height, width, and other parameters when downloading the parallel coordinates as an image. The default height and width produce a .jpeg or .png with 960 dpi that scales nicely on 8.5 x 11 inch paper. The -Label and title scale- may need increased if larger images are downloaded. If .pdf is desired, you can download as .svg then use free online applications to convert from .svg to .pdf. Use these options in conjunction with the label options above to produce quality images.", placement = "right", options=list(container="body")),

splitLayout(cellWidths = c(300,300), 
            sliderInput(inputId = "height",label = "Image height (px)",min = 100, max=1000, value = 500, width=250, step = 50),
            sliderInput(inputId = "width",label = "Image width (px)",min = 250, max=3000, value = 1000, width=250, step=50)
            
            ),


splitLayout(cellWidths = c(300,300), 
            
            sliderInput(inputId = "scale",label = "Label and title scale",min =1, max=17, value = 10, width=250),
            radioButtons(inputId = "format", label = "Image format", choices = c("jpeg", "png", "svg", "webp"), selected = "jpeg", width=250, inline=TRUE)
            
            ),


h3("Decision variable plot options"),
hr(), # add line
sliderInput(inputId = "DVplotLabelSize", label = "Label font size", min=1, max=5, value=2.7, step = 0.1),
bsTooltip(id="DVplotLabelSize", title = "Change the font size of the ID and shortage volume labels inside of the plot.", placement = "right", options=list(container="body")),


h3('Select SOW ensemble'),
hr(), # add line
selectInput('SOWensemble', label=NULL, selected='cLHS n500', choices=c('cLHS n500', 'cLHS n300')),
bsTooltip(id="SOWensemble", title="Robustness metrics have been calculated using 500 states of the world (SOW) and 300 SOW. The Rank Correlation page demonstrates that the results are largely the same for both ensembles. However, you can choose which ensemble is shown in parallel coordinates and decision variable plots.", options=list(container="body"), placement = "right"),



h3("Subset policies with Kennard Stone sampling"),
hr(), # add line
selectInput("KSmetric", label="Metric", choices = c("Decision Variables", "Optimization objectives"), selected = "Decision Variables"),
bsTooltip(id="KSmetric", title="You can select a subset of policies to view in the parallel coordinates and decision variable plots using the Kennard-Stone algorithm, which identifies the k most diverse policies. Select if diversity is based on decision variables or optimization objectives, then choose k, the number of policies. The policies will be sampled from policies in the global filter.", options=list(container="body"), placement = "right"),

sliderInput("KSnSample", label = "Number of policies", min = 2, max=463, value=463, step=4),
actionButton("KSApply", label = "Subset policies")
        
        )

observeEvent(input$SOWensemble,{

  reset$SOWchange=1

}, ignoreNULL = TRUE, ignoreInit = TRUE)

modalTrigger=reactiveValues(Explore=0, Custom=0)

observeEvent(modalTrigger$Explore | modalTrigger$Custom, {
  
  # modalTrigger$Explore=0
  # modalTrigger$Custom=0
  
  toggleModal(session=session,'modalSettings', toggle = "open")
  


  
}, ignoreInit = T)


delayFontSlider=reactive({ # slow down the speed at which sliderInput for DV Label size causes plot to rerender
  input$DVplotLabelSize
}
) %>% debounce(1000) # 1000 milliseconds, or 1 second.

```



```{r, global filters and resets, include= FALSE}

### global reset

# to have better control over many action buttons, have the action buttons adjust reactiveValues. Then, use the reactive values to trigger resets. For reference: https://gist.github.com/aagarw30/316a65598b048476819dce76504d154d
reset=reactiveValues(
  Optimization=0,
  Custom=0,
  Explore=0
)

observeEvent(input$resetOptimization, {
  reset$Optimization=reset$Optimization+1
  reset$Custom=0
  reset$Explore=0
}, priority = 0,  ignoreNULL = TRUE, ignoreInit = TRUE)

observeEvent(input$resetCustom, {
  reset$Optimization=0
  reset$Custom=reset$Custom+1
  reset$Explore=0
}, priority = 0,  ignoreNULL = TRUE, ignoreInit = TRUE)

observeEvent(input$resetExplore, {
  reset$Optimization=0
  reset$Custom=0
  reset$Explore=reset$Explore+1
}, priority = 0,  ignoreNULL = TRUE, ignoreInit = TRUE)

observeEvent(eventExpr = {reset$Optimization > 0 | reset$Custom > 0 | reset$Explore > 0},
             {global_filter$r=1:nrow(wide_data)

            showNotification('Global filter is reset', type='message', duration=7)

             in_global_filter$y=rep(1,nrow(wide_data))
             rangesExplore$a=NULL
             ranges$a=NULL
             rangesCustom$a=NULL
             filterLog$global=df.initialize
             filterLog$local=df.initialize}, priority = 10, ignoreNULL = TRUE, ignoreInit = TRUE)

### global filter column to add to data frames for coloring par coords
observeEvent(eventExpr = {input$global_filterOptimization | input$global_filterExplore | input$global_filterCustom}, {all=1:nrow(wide_data)
y=rep(1,length(all))
y[which(!(all %in% global_filter$r))]=0
in_global_filter$y=y
# cat(file=stderr(), 'global filter bin:', in_global_filter$y, "\n") # prints dimension to R console
# cat(file=stderr(), 'global filter:', global_filter$r, "\n") # prints dimension to R console
ranges$a=NULL
rangesExplore$a=NULL
rangesCustom$a=NULL}, priority =-1, ignoreNULL = TRUE, ignoreInit = TRUE)

```


For reference {data-orientation=columns}
=====================================

Column {.tabset .tabset-fade data-width=600}
-------------------------------------

### experimental design


```{r, background image}
#include_graphics('https://i.imgur.com/wX9ftwq.png')
output$IntroFig=renderImage({

          filename <- normalizePath("images/Overview.png")


          list(src=filename, width="1485px", height="860px")

        }, deleteFile = F)

fluidRow(column(width=11, offset = 1,
        imageOutput("IntroFig")        
                ))
```

### robustness metrics

```{r, robustness metrics documentation}
tags$iframe(style="height:1000px; width:100%; scrolling=yes",
src="www/Robustness pdf for app.pdf")
```

### example calculations

```{r}

googleSheet_embed_link <-"https://docs.google.com/spreadsheets/d/1qWXsX7_P73OalFdXVV3uHSZXQFoWD_Ccv98cOVqh-PY/edit?usp=sharing"

renderUI({
    tags$iframe(id = "googleSheet",
            src = googleSheet_embed_link,
            width = 1948,
            height = 850,
            frameborder = 0,
            marginheight = 0)
 })

```


Optimization objectives {data-orientation=rows}
=====================================  

Column {.sidebar data-width=225}
------------------------------------

```{r, Optimization UI}

splitLayout(cellWidths = c(130, 50), h3('Local filters'), circleButton(inputId = "LFHelpOptimization", icon = icon("info-circle"), size = "xs") )

bsTooltip(id = "LFHelpOptimization",title = "Local filters are saved only to the current page. To save these filters and apply additional filters on other pages, select Save Filters Globally.", options=list(container="body"), placement = "right" )

dropdownButton(circle=F, label='manual filters', width=190,
selectInput("VarOptimization1", label = "Filter 1:",
            choices = get_options('optimization'), selected = 'None'),
selectInput("IneqOptimization1", label = "Inequality 1:",
            choices = c('<', '>'), selected = '<'),
textInput('ThreshOptimization1', label= 'Threshold 1:', value='', placeholder='10'),

selectInput("VarOptimization2", label = "Filter 2:",
            choices = get_options('optimization'), selected = 'None'),
selectInput("IneqOptimization2", label = "Inequality 2:",
            choices = c('<', '>'), selected = '<'),
textInput('ThreshOptimization2', label= 'Threshold 2:', value='', placeholder='10'),

selectInput("VarOptimization3", label = "Filter 3:",
            choices = get_options('optimization'), selected = 'None'),
selectInput("IneqOptimization3", label = "Inequality 3:",
            choices = c('<', '>'), selected = '<'),
textInput('ThreshOptimization3', label= 'Threshold 3:', value='', placeholder='10'),

textInput("IDOptimization", label='Select policy IDs', placeholder='eg: 292,54'),

actionButton('manualfilterOptimization',label='save manual filters', width=170)
               
               )



div(style="margin-bottom:5px") # adds padding between buttons
actionButton('brushfilterOptimization',label='save brush filters', width=190)
div(style="margin-bottom:5px") # adds padding between buttons

h4("table selections:", align="center")

fluidRow(column(width=3,
  actionButton('tableKeepOptimization',label='keep', width=91)),
  column(width=3, offset=2,
  actionButton("tableRemoveOptimization", label="remove", width=93))
  )



div(style="margin-bottom:5px") # adds padding between buttons
actionButton('localresetOptimization',label='reset local filters', width=190)
div(style="margin-bottom:20px") # adds padding between buttons

splitLayout(cellWidths = c(150, 50), h3('Global filters'), circleButton(inputId = "GFHelpOptimization", icon = icon("info-circle"), size = "xs") )

bsTooltip(id = "GFHelpOptimization",title = "Global filters are honored on other pages. For example, filter policies by thresholds in Optimization objectives, save globally, then apply additional filters on the Robustness metrics page.", options=list(container="body"), placement = "right" )

actionButton('global_filterOptimization', label='save filters globally', width=190)
div(style="margin-bottom:5px") # adds padding between buttons
actionButton('resetOptimization',label='reset global filters', width=190)


h3('Plot variables')

selectInput('colorOptimization', label='ParCoords color variable', choices=c(get_options('optimization'),'global.filter'), selected = 'M1000', width=190)

selectInput('xAxisOptimization', label = 'Metric for ranking', choices=get_options('optimization')[-1], selected='M1000', width=190)

div(style="margin-bottom:20px") # adds padding between buttons


splitLayout(cellWidths = c(150, 50),
            downloadHandler(filename="optimization filtered policies.xlsx", content=function(file) {
  
  # remove empty rows in the log objects
  data=filterLog$global
  global=data[rowSums(is.na(data)) != ncol(data),]
  data=logOptimization$log
  local=data[rowSums(is.na(data)) != ncol(data),]

  data.list=list("policies"=select(filter.optimization(), -starts_with("X")), "global.filters"=global, "local.filters"=local)
  write.xlsx(data.list, file)

}),
            circleButton(inputId= "settingsOptimization", icon=icon("chart-line"), status = "primary")
            )

bsTooltip(id="settingsOptimization",title="global plot settings", options=list(container="body"), placement = "right")


```


```{r, Optimization process UI, include=FALSE}
#### initialize with all 463 policies
policiesIDOptimization=reactiveValues(r=1:nrow(wide_data))
manualIDOptimization=reactiveValues(r=1:nrow(wide_data))
interactiveIDOptimization=reactiveValues(r=1:nrow(wide_data))

logOptimization=reactiveValues(log=df.initialize)
#### update manualIDOptimization based on user input

observeEvent(input$manualfilterOptimization, {
  
  temp=manual_filters(ID_key='IDOptimization', unique_thresh_ID = 'Optimization',dataframe = optimization$g, page="optimization") # returns list of ID and log
  manualIDOptimization$r=temp[[1]]
  
  logOptimization$log=rbind(logOptimization$log, temp[[2]])
  
}, ignoreInit = T, ignoreNULL = T)

#### update interactiveIDOptimization based on par coords brushing
ranges <- reactiveValues(a=list())

#### get ranges from brushing

observeEvent(eventExpr = event_data("plotly_restyle", source = "pcoords"),{
  temp=get_brush_ranges(source = "pcoords", prep_df = prep$optimization)
  if (is.na(temp)){
    # do nothing
  } else {
     ranges$a[[temp[[1]]]]=temp[[2]]
     
  }
})

#### get policies from brushing
observeEvent(input$brushfilterOptimization,{
  temp=get_brush_policyID(ranges=ranges$a, prep_df = prep$optimization, page="optimization") # returns list of policy IDs and log
  interactiveIDOptimization$r=temp[[1]]
  
  # update log
  
  logOptimization$log=rbind(logOptimization$log, temp[[2]])
})

### update policiesIDOptimization as intersection of global filter, manual filter, and interactive filter

observe({
  a=intersect(manualIDOptimization$r, interactiveIDOptimization$r)
  b=intersect(a, global_filter$r)
  
  policiesIDOptimization$r=b
}
)



observeEvent(input$tableKeepOptimization, {
  
  policiesIDOptimization$r=intersect(policiesIDOptimization$r, tableSelectOptimization$id)
  
  add_vec=c("Optimization", "ID", "table keep", NA, NA, paste(as.character(tableSelectOptimization$id), collapse=","))
  
  temp=df.initialize
  temp[1,]=add_vec
  
  logOptimization$log=rbind(logOptimization$log,temp)
  
}, ignoreInit = T)

observeEvent(input$tableRemoveOptimization, {
  
  all=1:nrow(wide_data)
  subset=all[-tableSelectOptimization$id]
  
  policiesIDOptimization$r=intersect(policiesIDOptimization$r, subset)
  
  add_vec=c("Optimization", "ID", "table remove", NA, NA, paste(as.character(tableSelectOptimization$id), collapse=","))
  temp=df.initialize
  temp[1,]=add_vec
  logOptimization$log=rbind(logOptimization$log, temp)
  
}, ignoreInit = T)



### establish filter.optimization

filter.optimization=reactive({ # because optimization() already accounts for global filter, filter.optimization is intersection of global and local POLICY ID filter only
  
  dplyr::filter(optimization$g, ID %in% policiesIDOptimization$r)
  
})

### apply global filter

observeEvent(input$global_filterOptimization, {
  
  global_filter$r=intersect(global_filter$r, policiesIDOptimization$r)
  
  remaining=length(global_filter$r)
  showNotification(paste(remaining, 'policies remain in global filter', sep=' ' ), type='message', duration=7)
  
  #transfer local log to global log
  filterLog$global=rbind(filterLog$global, logOptimization$log)
  
})


### local reset button

observeEvent(input$localresetOptimization, {
  policiesIDOptimization$r=1:nrow(wide_data)
  manualIDOptimization$r=1:nrow(wide_data)
  interactiveIDOptimization$r=1:nrow(wide_data)
  tableSelectOptimization$id=NULL
  ranges$a=NULL
  logOptimization$log=df.initialize
})

  # also, if color changes, reset local filters

observeEvent(input$colorOptimization,{
  #   policiesIDOptimization$r=1:nrow(wide_data)
  # manualIDOptimization$r=1:nrow(wide_data)
  interactiveIDOptimization$r=1:nrow(wide_data)
  ranges$a=NULL
  
  rows=which(logOptimization$log$filter.type=="brush")
  logOptimization$log=logOptimization$log[-rows,]
  
})

```

Row {data-height=325}    
-------------------------------------
### optimization objectives  

```{r, Optimization par_coords}

labelsOptimization=colnames(metrics_4app_n500$optimization)


plotlyOutput("pc1")


output$pc1=renderPlotly({
  
  isTruthy(input$localresetOptimization) # adding this statement causes interactive filters to reset,
  
  if (input$KeepPoliciesTF==TRUE){
    data=data.frame(optimization$all,global.filter=in_global_filter$y[KS$index])
  } else if (input$KeepPoliciesTF==FALSE){
    data=filter.optimization()
  } else {
    data=data.frame(optimization$all,global.filter=in_global_filter$y[KS$index])
  }

  
  ## create matrix of policy ID constraints that considers both the global filter plus table selections
  bind=rbind(tableSelectOptimization$constraints, global_filter$constraints) # bind table and global filter matrices
  
  if(TRUE %in% duplicated(bind)){ # check if any duplicate rows. If so, then the user has selected data in the table and only that should be highlighted
    policy_ID_constraints=bind[duplicated(bind),]
  } else {
    policy_ID_constraints=global_filter$constraints # if no duplicates, then color only policies in global filter
  }

  p=par_coords(data=data, n_var=9,
             color_var = input$colorOptimization, title='Optimization objectives', labels=labelsOptimization, source='pcoords', policy_ID = policy_ID_constraints, colorbarTitle = input$colorOptimization, axes_data=metrics.list_n500$optimization)
  p=event_register(p,"plotly_restyle")
  p
  
})



```

Row {.tabset .tabset-fade data-height=275}    
-------------------------------------
    
### Rank of filtered policies for selected metric
    
```{r}
############# Optimization DV plot

renderPlotly({

  input$resetOptimization

  DV_plot(metric=data.frame(metrics.list$l$optimization, add_to_tradeoff), to_plot = filter.optimization()[["ID"]], preferred_direction = 'min',
          metric_label = input$xAxisOptimization)
  

})

```

### Table of filtered policies

```{r}
  output$optimization_data <- DT::renderDataTable({
    input$localresetOptimization
    select(filter.optimization(), -starts_with("X"))
  },options = list(scrollY="245px", scrollX="100px", pageLength=10), server = TRUE, filter="none", rownames=FALSE
)

DT::dataTableOutput("optimization_data")

tableSelectOptimization=reactiveValues(id=NULL)


observe({
  tableSelectOptimization$id=filter.optimization()[['ID']][input$optimization_data_rows_selected]
  a=tableSelectOptimization$id-.001
  b=tableSelectOptimization$id+.001
  tableSelectOptimization$constraints=matrix(c(a,b),ncol=2, byrow = FALSE)})



```



Robustness metrics {data-orientation=rows}
==========================================

Column{.sidebar data-width=225}
-------------------------------

```{r, Exploration UI}

df_names=names(metrics_4app_n500)
# remove Hurwicz.OP and mean.variance. No longer of interest in this research.
#df_names=df_names[-which(df_names %in% c("Hurwicz.OP", "mean.variance"))]
name=reactiveValues(n='satisficing')
observeEvent(input$active_tab,{
    name$n=df_names[input$active_tab+1]
    #cat(file=stderr(), 'name$n=', name$n, "\n") # prints page name to console for debugging
})

# Hurwicz
renderUI({
  req(name$n=="Hurwicz.OP")
  sliderInput("HurwicWeight", label="Best-case weight", min=0, max=1, value=0.5, step=0.05, width=170, ticks = F)
})

renderUI({
  req(name$n=="Hurwicz.OP")
  req(Hurwicdf$calcWeight != input$HurwicWeight) # only give option to calculate if weight has changed
  
  actionButton("HurwicCalc", label= "update weight", width=190, class="btn-warning")
  
})

# Maximin
renderUI({
  req(name$n=="maximin")
  sliderInput("maximinPercentile", label="Maximin percentile", min=0, max=100, value=100, step=5, width=170, ticks = F)
})

renderUI({
  req(name$n=="maximin")
  req(maximindf$calcPerc != input$maximinPercentile) # only give option to calculate if weight has changed
  
  actionButton("maximinCalc", label= "update percentile", width=190, class="btn-warning")
  
})

# satisficing

renderUI({
  req(name$n=="satisficing")

  dropdownButton(inputId = "satisficingDropDown",label='Satisficing calcs', circle = F, width = 220,

  selectInput("satisObj",label="Select objective(s)", multiple = T, choices=colnames(obj_all)[-c(1,2)]),

  renderUI({
    req(length(input$satisObj) >=1)
    sliderInput("satisThresh1", label=paste0(input$satisObj[1], " threshold"), min=min(obj_all[[input$satisObj[1]]]),
                max=max(obj_all[[input$satisObj[1]]]), value=median(obj_all[[input$satisObj[1]]]))
    }),

    renderUI({
    req(length(input$satisObj) >=2)
    sliderInput("satisThresh2", label=paste0(input$satisObj[2], " threshold"), min=min(obj_all[[input$satisObj[2]]]),
                max=max(obj_all[[input$satisObj[2]]]), value=median(obj_all[[input$satisObj[2]]]))
    }),

    renderUI({
    req(length(input$satisObj) >=3)
    sliderInput("satisThresh3", label=paste0(input$satisObj[3], " threshold"), min=min(obj_all[[input$satisObj[3]]]),
                max=max(obj_all[[input$satisObj[3]]]), value=median(obj_all[[input$satisObj[3]]]))
    }),

    renderUI({
    req(length(input$satisObj) >=4)
    sliderInput("satisThresh4", label=paste0(input$satisObj[1], " threshold"), min=min(obj_all[[input$satisObj[4]]]),
                max=max(obj_all[[input$satisObj[4]]]), value=median(obj_all[[input$satisObj[4]]]))
    }),

    renderUI({
    req(length(input$satisObj) >=5)
    sliderInput("satisThresh5", label=paste0(input$satisObj[5], " threshold"), min=min(obj_all[[input$satisObj[5]]]),
                max=max(obj_all[[input$satisObj[5]]]), value=median(obj_all[[input$satisObj[5]]]))
    }),

    renderUI({
    req(length(input$satisObj) >=6)
    sliderInput("satisThresh6", label=paste0(input$satisObj[6], " threshold"), min=min(obj_all[[input$satisObj[6]]]),
                max=max(obj_all[[input$satisObj[6]]]), value=median(obj_all[[input$satisObj[6]]]))
    }),

    renderUI({
    req(length(input$satisObj) >=7)
    sliderInput("satisThresh7", label=paste0(input$satisObj[7], " threshold"), min=min(obj_all[[input$satisObj[7]]]),
                max=max(obj_all[[input$satisObj[7]]]), value=median(obj_all[[input$satisObj[7]]]))
    }),

    renderUI({
    req(length(input$satisObj) >=8)
    sliderInput("satisThresh8", label=paste0(input$satisObj[8], " threshold"), min=min(obj_all[[input$satisObj[8]]]),
                max=max(obj_all[[input$satisObj[8]]]), value=median(obj_all[[input$satisObj[8]]]))
    }),

  div(style="margin-bottom:20px"), # adds padding between buttons

  renderUI({
    req(length(input$satisObj) >=2)
    h4('Aggregate objectives?')
    prettyToggle("AggTF", value=FALSE, label_on = "Aggregrate objectives", label_off = "Don't aggregrate objectives", width = '200px', bigger=T)
    }),

  div(style="margin-bottom:20px"), # adds padding between buttons

  renderUI({
    req(length(input$satisObj) >=1)
    actionButton("CalcSatis", label="Calculate")
  }),
  
  bsTooltip(id="satisficingDropDown", title="Satisficing and satisficing deviation metrics require user defined performance thresholds to delineate acceptable vs. unacceptable performance. Use this dropdown to select optimization objectives and corresponding performance thresholds.", options=list(container="body"), placement = "right")

                   )

})



# get options for manual filters, par coords color var, and x axis
observe({
    req(name$n)
  
  if (name$n=="satisficing"){ # special function for satisficing because user can change names of the axes
    Explore_all$options=get_satisficing_options()[-1]
  } else {
    Explore_all$options=get_options(name$n)[-1]
  }
})


splitLayout(cellWidths = c(130, 50), h3('Local filters'), circleButton(inputId = "LFHelpExplore", icon = icon("info-circle"), size = "xs") )

bsTooltip(id = "LFHelpExplore",title = "Local filters are saved only to the current page. Further, on the Robustness metrics page, local filters are only saved to each tab for each class of robustness metrics. To save these filters and apply additional filters on other pages or tabs, select Save Filters Globally.", options=list(container="body"), placement = "right" )



dropdownButton(label='manual filters', circle = F, width = 190,
               
renderUI({
  req(name$n)
  selectInput("VarExplore1", label = "Filter 1:",
            choices = c("None", Explore_all$options), selected = 'None')
}),

renderUI({
    req(name$n)
    selectInput("IneqExplore1", label = "Inequality 1:",
            choices = c('<', '>'), selected = '<')
}),

renderUI({
  req(name$n)
  textInput('ThreshExplore1', label= 'Threshold 1:', value='', placeholder='10')

}),

renderUI({
  req(name$n)
  selectInput("VarExplore2", label = "Filter 2:",
            choices = c("None", Explore_all$options), selected = 'None')
}),

renderUI({
      req(name$n)
    selectInput("IneqExplore2", label = "Inequality 2:",
            choices = c('<', '>'), selected = '<')
  
}),

renderUI({
    req(name$n)
  textInput('ThreshExplore2', label= 'Threshold 2:', value='', placeholder='10')

}),

renderUI({
  req(name$n)
  selectInput("VarExplore3", label = "Filter 3:",
            choices = c("None", Explore_all$options), selected = 'None')
}),

renderUI({
      req(name$n)
    selectInput("IneqExplore3", label = "Inequality 3:",
            choices = c('<', '>'), selected = '<')
  
}),

renderUI({
    req(name$n)
  textInput('ThreshExplore3', label= 'Threshold 3:', value='', placeholder='10')

}),

renderUI({
  req(name$n)
  textInput("IDExplore", label='Select policy IDs', placeholder='eg: 292,54')
}),

renderUI({
  req(name$n)
  actionButton('manualfilterExplore', 'save manual filters', width=170)
})

)

div(style="margin-bottom:5px") # adds padding between buttons

renderUI({
  req(name$n)
  actionButton('brushfilterExplore',label='save brush filters', width=190)

})
div(style="margin-bottom:5px") # adds padding between buttons

h4("table selections:", align="center")

renderUI({
  req(name$n)
  
  fluidRow(column(width=3,
    actionButton('tableKeepExplore',label='keep', width=91)),
    column(width=3, offset=2,
    actionButton("tableRemoveExplore", label="remove", width=93))
    )

})
div(style="margin-bottom:5px") # adds padding between buttons

renderUI({
  req(name$n)
  actionButton('localresetExplore',label='reset local filters', width=190)

})
div(style="margin-bottom:10px") # adds padding between buttons


splitLayout(cellWidths = c(150, 50), h3('Global filters'), circleButton(inputId = "GFHelpExplore", icon = icon("info-circle"), size = "xs") )

bsTooltip(id = "GFHelpExplore",title = "Global filters are honored on other pages. For example, filter policies by thresholds in Satisficing-related robustness metrics, save globally, then apply additional filters on the Maximin tab or Optimization objectives page.", options=list(container="body"), placement = "right" )

renderUI({
  req(name$n)
  actionButton('global_filterExplore', label='save filters globally', width=190)
})
div(style="margin-bottom:5px") # adds padding between buttons

renderUI({
  req(name$n)
  actionButton('resetExplore',label='reset global filters', width=190)
})

div(style="margin-bottom:5px") # adds padding between buttons


h3("Plot variables")
renderUI({
  req(name$n)

  selectInput('colorExplore', label='ParCoords color variable', choices=c(Explore_all$options, 'global.filter', 'front'), selected = Explore_all$options[1], width=190)

})

renderUI({
  req(name$n)
  
  selectInput('xAxisExplore', label = 'Metric for ranking', choices=Explore_all$options, selected=Explore_all$options[1], width=190)
})

splitLayout(cellWidths = c(150,50),
            
            downloadHandler(filename="Exploration filtered policies.xlsx", content=function(file) {
  
    # remove empty rows in the log objects
  data=filterLog$global
  global=data[rowSums(is.na(data)) != ncol(data),]
  data=logExplore$log
  local=data[rowSums(is.na(data)) != ncol(data),]

  data.list=list("policies"=select(filter.Explore(), -starts_with("X")), "global.filters"=global, "local.filters"=local)
  write.xlsx(data.list, file)

}), 
circleButton(inputId= "settingsExplore", icon=icon("chart-line"), status = "primary")

            )

bsTooltip(id="settingsExplore",title="global plot settings", options=list(container="body"), placement = "right")

observeEvent(input$settingsExplore, {modalTrigger$Explore=1+modalTrigger$Explore}, ignoreInit = T)


```



<script>
 $("body").on("shown.bs.tab", "a[data-toggle='tab']", function(e){
    Shiny.setInputValue("active_page", window.location.href);
 })
</script>

<script>
  $("body").on("shown.bs.tab", "div[id='section-row-2'] a.nav-link", function(e){
    Shiny.setInputValue("active_tab", $(e.target).parent().index());
  })
</script>


```{r, Exploration process tabs, include=FALSE}

# the above JavaScript code was taken originally from here:
# https://stackoverflow.com/questions/64306794/how-to-get-the-current-active-tab-in-a-flexdashboard-document-to-reactively-disp

# I created two versions of the script from stackoverflow to perform two tasks, each using the jquery on(events [,selector], handler) function differently. Both on() function calls look for user to click. Then, the selecter argument and handler argument differs

# The first script uses the selector 'a[data-toggle='tab']' and the handler saves the page url via window.location.href. This means whenever a tab is toggled, the url is saved to input$active_page. I use this to track when 'Metric exploration' page is active
# see here for window.location.href: https://www.w3schools.com/js/js_window_location.asp
# see here for on() function: https://api.jquery.com/on/


# The second script tracks the tab index of the active par-coords in Metric exploration page. To avoid the tab index changing when on other pages or when changing between DV plot and table, I use the selector "div[id='section-row-2']". I discovered that this selector is unique to the Metric exploraiton page and par_coords (top) row. The bottom row (DV plot and table) has id='section-row-3', so changes in the tabs there are not registered as an event. I figured this out by opening the .html console log then exploring through the elements tab. To reach the .html console log, right click on the app when opened in a browser then selcect 'Inspect'



# preallocate reactiveValues used to track which page and tab the user is on
page=reactiveValues(ID="for-reference")
tab=reactiveValues(ID=0)
# count=reactiveValues(c=0)

# get the name of the active page. ie, optimization, for reference, metric exploration
observeEvent(input$active_page, {
  extract=sub(".*/#section-", "", input$active_page) # obtain characters after /#section- in the html address
  page$ID=extract
  #cat(file=stderr(), 'page$ID=', page$ID, "\n") # prints page name to console for debugging
  #cat(file=stderr(), 'input$active_page=', input$active_page, "\n") # prints page name to console for debugging

})


Explore_all=reactiveValues(df=metrics_4app_n500$satisficing, options=get_options("satisficing")[-1], axes=metrics_4app_n500$satisficing, ID_constraints=NULL)


observe({
  
  #cat(file=stderr(), 'input$active_tab=', input$active_tab, "\n")
  #cat(file=stderr(), 'tab$ID=', tab$ID, "\n")

  
  if (!isTruthy(input$active_tab)){
    Explore_all$df=prep$satisficing
    Explore_all$axes=metrics_4app$l$satisficing
  } else if (input$active_tab==0){
    Explore_all$df=prep$satisficing
    Explore_all$axes=metrics_4app$l$satisficing
  } else if (input$active_tab==1){
    Explore_all$df=prep$regret2
    Explore_all$axes=metrics_4app$l$regret.from.best
  } else if (input$active_tab==2){
    Explore_all$df=prep$percent_deviation
    Explore_all$axes=metrics_4app$l$percent.deviation
  } else if (input$active_tab==3){
    Explore_all$df=prep$mean
    Explore_all$axes=metrics_4app$l$mean
  } else if (input$active_tab==4){
    Explore_all$df=prep$Hurwicz # Currently removed from app. Metric no longer of interest
    Explore_all$axes=metrics_4app$l$Hurwicz.OP
  } else if (input$active_tab==5){
    Explore_all$df=prep$mean_var # Currently removed from app. Metric no longer of interest
    Explore_all$axes=metrics_4app$l$mean.variance 
  } else if (input$active_tab==6) {
    Explore_all$df=prep$maximin
    Explore_all$axes=metrics_4app$l$maximin
  } else {
    Explore_all$df=prep$satisficing
    Explore_all$axes=metrics_4app$l$satisficing

  }

})

Explore=reactiveValues()


observe({
  Explore$df=dplyr::filter(Explore_all$df, ID %in% global_filter$r)
})


```

```{r, process Exploration UI}


#### initialize with all 463 policies
policiesIDExplore=reactiveValues(r=1:nrow(wide_data))
manualIDExplore=reactiveValues(r=1:nrow(wide_data))
interactiveIDExplore=reactiveValues(r=1:nrow(wide_data))

logExplore=reactiveValues(log=df.initialize)

#### update manualIDExplore based on user input

observeEvent(input$manualfilterExplore, {
  temp=manual_filters(ID_key='IDExplore', unique_thresh_ID = 'Explore',dataframe = Explore$df, page=paste0("Explore.",name$n))
  manualIDExplore$r=temp[[1]]
  
  logExplore$log=rbind(logExplore$log, temp[[2]])
})

#### update interactiveIDExplore based on par coords brushing
rangesExplore <- reactiveValues(a=list())

#### get ranges from brushing

observeEvent(eventExpr = event_data("plotly_restyle", source = name$n),{

  temp=get_brush_ranges(source = name$n, prep_df = Explore_all$df)
    if (is.na(temp)){
    # do nothing
  } else {
     rangesExplore$a[[temp[[1]]]]=temp[[2]]
     
  }
  # cat(file=stderr(), 'trying to filter df:', name$n, "\n")
  # cat(file=stderr(), 'trying to filter metric:', temp[[1]], "\n")

})

#### get policies from brushing

observeEvent(input$brushfilterExplore,{

  temp=get_brush_policyID(ranges=rangesExplore$a, prep_df = Explore_all$df, page=paste0("Explore.",name$n))
  
  interactiveIDExplore$r=temp[[1]]
  
  # update log
  
  logExplore$log=rbind(logExplore$log, temp[[2]])
  
})


### update policiesIDExplore as intersection of global filter, manual filter, and interactive filter

observe({
  a=intersect(manualIDExplore$r, interactiveIDExplore$r)
  b=intersect(a, global_filter$r)
  policiesIDExplore$r=b
}
)

### update policies for selections from table
observeEvent(input$tableKeepExplore, {
  policiesIDExplore$r=intersect(policiesIDExplore$r, tableSelectExplore$id)
  
  add_vec=c(paste0("Explore.", name$n), "ID", "table keep", NA, NA, paste(as.character(tableSelectExplore$id), collapse=","))
  temp=df.initialize
  temp[1,]=add_vec
  logExplore$log=rbind(logExplore$log, temp)
  
}, ignoreInit = T)

observeEvent(input$tableRemoveExplore, {
  
  all=1:nrow(wide_data)
  subset=all[-tableSelectExplore$id]
  
  policiesIDExplore$r=intersect(policiesIDExplore$r, subset)
  
  add_vec=c(paste0("Explore.", name$n), "ID", "table remove", NA, NA, paste(as.character(tableSelectExplore$id), collapse=","))
  temp=df.initialize
  temp[1,]=add_vec
  logExplore$log=rbind(logExplore$log, temp)
  
}, ignoreInit = T)

### establish filter.Explore

filter.Explore=reactive({ # because Explore$df already accounts for global filter, filter.Explore is intersection of global and local POLICY ID filter only

  dplyr::filter(Explore$df, ID %in% policiesIDExplore$r)

})

### apply global filter

observeEvent(input$global_filterExplore, {
  global_filter$r=intersect(global_filter$r, policiesIDExplore$r)
  
  remaining=length(global_filter$r)
  showNotification(paste(remaining, 'policies remain in global filter', sep=' ' ), type='message', duration=7)
  
  filterLog$global=rbind(filterLog$global, logExplore$log)
})


### local reset button

observeEvent(name$n,{ # wipe clean the brush filters when you change pages, or you will have brush ranges on previous pages affect your current page
  rangesExplore$a=NULL
  interactiveIDExplore$r=1:nrow(wide_data)

})


observeEvent(input$localresetExplore, {
  policiesIDExplore$r=1:nrow(wide_data)
  manualIDExplore$r=1:nrow(wide_data)
  interactiveIDExplore$r=1:nrow(wide_data)
  tableSelectExplore$id=NULL
  rangesExplore$a=NULL
  logExplore$log=df.initialize
})

  # also, if color changes, reset local filters

observeEvent(input$colorExplore,{
  #   policiesIDExplore$r=1:nrow(wide_data)
  # manualIDExplore$r=1:nrow(wide_data)
  interactiveIDExplore$r=1:nrow(wide_data)
  rangesExplore$a=NULL
  
  rows=which(logExplore$log$filter.type=="brush")
  logExplore$log=logExplore$log[-rows,]
  
})


```


Row {.tabset .tabset-fade data-height=325}
-------------------------------------------


```{r, calculate satisficing}
# create unit mapping. I use this to update Par Coords title
units=data.frame(LB.Avg="KAF", LB.Avg.Policy="KAF", LF.Deficit= "%", M1000="%",
                 P3490="%", LB.Dur="Yr", LB.Freq="%", LB.Max="KAF", P.WYR="MAF")


satisdf=reactiveValues(df=metrics.list_n500$satisficing, trigger=0, title="Satisficing: M1000 < 10% & P3490 < 5% & LB.Avg < 600KAF", AggTF=FALSE) # establish reactive object to store satisficing dataframe

# update AggTF with user input
observeEvent(input$AggTF, {
  satisdf$AggTF=input$AggTF
})

observeEvent(input$CalcSatis, {
  
  showNotification('Calculating', type='message', duration=7)
  
  satisdf$df=NULL # reset satisdf
  
  # change the ensemble based on user input
  if (input$SOWensemble=="cLHS n300"){
    obj=dplyr::filter(obj, TraceNumber %in% SOW_id) # filter CRSS objectives output to the 300 SOW
  } else {
    obj=obj_all
  }
  
  # names=input$satisObj
  # cat(file=stderr(), 'names:', names, "\n")
  
  # create thresholds vector
  thresholds=vector() # create vector
  satisdf$title="Satisficing:"
  for (i in 1:8){
    if(is.null(input[[paste0("satisThresh",i)]])){ # if Null, exit loop
      break
    } else {
      thresholds[i]=input[[paste0("satisThresh",i)]]
      add_to_title=paste0(input$satisObj[i], " < ", thresholds[i], units[[input$satisObj[i]]])
    }
    
    
    if (i==1){
      satisdf$title=paste(satisdf$title, add_to_title, sep=" ")
    } else {
      satisdf$title=paste(satisdf$title, "&", add_to_title, sep=" ")
    }
    
  }
  
  # thresholds=unlist(lapply(str_split(input$satisThresh, ','), as.integer))
  # check=input$satisThresh
  # cat(file=stderr(), 'thresholds:', thresholds, "\n")
  
  if(satisdf$AggTF == TRUE){
    # calculate satisficing
    df=satisficing(data=obj, objectives = input$satisObj, thresholds = thresholds)
    colnames(df)[2]="satisficing"
    
    add=satisficing.deviation(data=obj, objectives = input$satisObj, thresholds = thresholds)[,2]
    df=cbind(df,add)
    colnames(df)[3]="sat.deviation"
    
  } else {
    # for loop to calculate satisficing for each objective
    
      for (i in 1:length(input$satisObj)){ # satisficing
        
        if(i==1){# initialize df
          df=satisficing(data=obj, objectives = input$satisObj[i], thresholds=thresholds[i])
          colnames(df)[2]=paste0('sat.',input$satisObj[i])
        } else { #
          add=satisficing(data=obj, objectives = input$satisObj[i], thresholds=thresholds[i])[,2]
          df=cbind(df,add)
          colnames(df)[ncol(df)]=paste0('sat.',input$satisObj[i])
          
        }
        
      } # end satisficing
    
      for (i in 1:length(input$satisObj)){ #satisficing deviation
        
        add=satisficing.deviation(data=obj, objectives = input$satisObj[i], thresholds = thresholds[i])[,2]
        df=cbind(df,add)
        colnames(df)[ncol(df)]=paste0("sat.dev.",input$satisObj[i])
        
      }
    
  }
  
  satisdf$df=df # update satisdf
#   check=dim(satisdf$df)
# cat(file=stderr(), 'dimensions:', check, "\n") # prints dimension to R console

    metrics.list$l$satisficing=df # update both metrics list. prep$satisficing will update because of dependency
    metrics_4app$l$satisficing=df
    
    satisdf$trigger=1 # triggers subsetting of prep$satisficing by KS$index

  showNotification('Satisficing thresholds updated', type='message', duration=7)
  
})


```


### Satisficing-related
```{r, satisficing par coords}

plotlyOutput("pcSatisficing")


observe({
    ## create matrix of policy ID constraints that considers both the global filter plus table selections
  bind=rbind(tableSelectExplore$constraints, global_filter$constraints) # bind table and global filter matrices
  
  if(TRUE %in% duplicated(bind)){ # check if any duplicate rows. If so, then the user has selected data in the table and only that should be highlighted
    Explore_all$ID_constraints=bind[duplicated(bind),]
  } else {
    Explore_all$ID_constraints=global_filter$constraints # if no duplicates, then color only policies in global filter
  }
})


output$pcSatisficing=renderPlotly({
  
  req(isTruthy(Explore_all$df))
  req(isTruthy(input$colorExplore))
  
  isTruthy(input$localresetExplore) # adding this statement causes interactive filters to reset,

    if (input$KeepPoliciesTF==TRUE){
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  } else if (input$KeepPoliciesTF==FALSE){
    data=filter.Explore()
  } else {
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  }
  
  nvar=which(colnames(Explore_all$df)==colnames(add_to_tradeoff)[1])-1 # find where add_to_tradeoff begins, substract one index
  # max_cols=which(startsWith(colnames(Explore_all$df), "satisficing."))
  
  m1=which(startsWith(colnames(Explore_all$df), "sat.dev."))
  m2=which(startsWith(colnames(Explore_all$df), "front"))
  m3=which(startsWith(colnames(Explore_all$df), "ID"))

  dontflip=c(m1,m2,m3)
  
  max_cols=which( ((1:ncol(Explore_all$df)) %in% dontflip) ==F )

  p=par_coords(data=data, n_var=nvar, 
             color_var = input$colorExplore, title=satisdf$title, labels=colnames(Explore_all$df)[1:nvar], max_cols = max_cols, source='satisficing', policy_ID = Explore_all$ID_constraints, colorbarTitle = input$colorExplore, axes_data=Explore_all$axes, show_ID_front=input$ShowID_Front, labelangle=input$labelangle, titlesize=input$titlesize)
  p=event_register(p,"plotly_restyle")
  p
  
})


```

### Regret from best
```{r, par coords regret from best}

labelsregret.from.best=colnames(metrics_4app_n500$regret.from.best)


output$pcRegret.From.Best=renderPlotly({
  
  req(isTruthy(Explore_all$df))
  req(isTruthy(input$colorExplore))
  
  isTruthy(input$localresetExplore) # adding this statement causes interactive filters to reset,

    if (input$KeepPoliciesTF==TRUE){
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  } else if (input$KeepPoliciesTF==FALSE){
    data=filter.Explore()
  } else {
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  }
  
  
  p=par_coords(data=data, n_var=10, 
             color_var = input$colorExplore, title='Regret from best', labels=labelsregret.from.best, source='regret.from.best', policy_ID = Explore_all$ID_constraints, colorbarTitle = input$colorExplore, axes_data=Explore_all$axes, show_ID_front=input$ShowID_Front, labelangle=input$labelangle, titlesize=input$titlesize)
  p=event_register(p,"plotly_restyle")
  p
  
})

plotlyOutput("pcRegret.From.Best")

```

### Percent deviation
```{r, par coords percent deviation}


labelsPercent.Deviation=colnames(metrics_4app_n500$percent.deviation)

plotlyOutput("pcPercent.Deviation")


output$pcPercent.Deviation=renderPlotly({
  
  req(isTruthy(Explore_all$df))
  req(isTruthy(input$colorExplore))
  
  isTruthy(input$localresetExplore) # adding this statement causes interactive filters to reset,

  
    if (input$KeepPoliciesTF==TRUE){
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  } else if (input$KeepPoliciesTF==FALSE){
    data=filter.Explore()
  } else {
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  }
  
  p=par_coords(data=data, n_var=10, 
             color_var = input$colorExplore, title='Percent deviation from optimization', labels=labelsPercent.Deviation, source='percent.deviation', policy_ID = Explore_all$ID_constraints, colorbarTitle = input$colorExplore, axes_data=Explore_all$axes, show_ID_front=input$ShowID_Front, labelangle=input$labelangle, titlesize=input$titlesize)
  p=event_register(p,"plotly_restyle")
  p
  
})

```

### Mean
```{r, par coords mean}

labelsmean=colnames(metrics_4app_n500$mean)

plotlyOutput("pcmean")


output$pcmean=renderPlotly({
  
  req(isTruthy(Explore_all$df))
  req(isTruthy(input$colorExplore))
  
  isTruthy(input$localresetExplore) # adding this statement causes interactive filters to reset,

  
    if (input$KeepPoliciesTF==TRUE){
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  } else if (input$KeepPoliciesTF==FALSE){
    data=filter.Explore()
  } else {
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  }
  
  
  p=par_coords(data=data, n_var=10, 
             color_var = input$colorExplore, title='mean', labels=labelsmean, source='mean', policy_ID = Explore_all$ID_constraints, colorbarTitle = input$colorExplore, axes_data=Explore_all$axes, show_ID_front=input$ShowID_Front, labelangle=input$labelangle, titlesize=input$titlesize)
  p=event_register(p,"plotly_restyle")
  p
  
})


```


### Hurwicz optimism-pessimism
```{r, HurwicOP calcs, include=FALSE}


Hurwicdf=reactiveValues(df=metrics.list_n500$Hurwicz.OP, calcWeight=0.5, trigger=0) # establish reactive object to store Hurwic dataframe

observeEvent(input$HurwicCalc, {

  showNotification('Calculating', type='message', duration=7)

  Hurwicdf$df=NULL # reset Hurwicdf

  # change the ensemble based on user input
  if (input$SOWensemble=="cLHS n300"){
    obj=dplyr::filter(obj, TraceNumber %in% SOW_id) # filter CRSS objectives output to the 300 SOW
  } else {
    obj=obj_all
  }

  df=HurwiczOP(data=obj, objectives=colnames(obj)[-c(1,2)], best_case_weight = input$HurwicWeight)

  Hurwicdf$df=df # update

  Hurwicdf$calcWeight=input$HurwicWeight # update weight of current calculations

  metrics.list$l$Hurwicz.OP=df # update both metrics list. prep$Hurwicz updates because of dependency
  metrics_4app$l$Hurwicz.OP=df

  Hurwicdf$trigger=1

  showNotification('Hurwic OP weights updated', type='message', duration=7)

}, ignoreNULL = T, ignoreInit = T)

```

```{r, Hurwicz PC}

labelsHurwicz.OP=colnames(metrics_4app_n500$Hurwicz.OP)


plotlyOutput("pcHurwicz.OP")


output$pcHurwicz.OP=renderPlotly({

  req(isTruthy(Explore_all$df))
  req(isTruthy(input$colorExplore))

  weight=isolate(input$HurwicWeight) # I want title to reflect the weight without renderPlotly taking a dependency on it
  if (is.null(weight)){
    weight=0.5 # so the title is loaded with correct values upon app initialization
  }
  isTruthy(input$localresetExplore) # adding this statement causes interactive filters to reset when local reset button applied

    if (input$KeepPoliciesTF==TRUE){
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  } else if (input$KeepPoliciesTF==FALSE){
    data=filter.Explore()
  } else {
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  }


  nvar=if("front" %in% colnames(data)) {10} else {9} # 10 axes if front is included, 9 otherwise

  p=par_coords(data=data, n_var=nvar,
             color_var = input$colorExplore, title=paste0('Hurwicz Optimism-Pessimism: best-case weight = ', weight, " , worst-case weight = ", (1-weight) ), labels=labelsHurwicz.OP, source='Hurwicz.OP', policy_ID = Explore_all$ID_constraints, colorbarTitle = input$colorExplore, axes_data=Explore_all$axes, show_ID_front=input$ShowID_Front, labelangle=input$labelangle, titlesize=input$titlesize)
  p=event_register(p,"plotly_restyle")
  p

})


```


### Mean-variance

```{r, par coords mean variance}


labelsmean.variance=colnames(metrics_4app_n500$mean.variance)

plotlyOutput("pcmean.variance")


output$pcmean.variance=renderPlotly({

  req(isTruthy(Explore_all$df))
  req(isTruthy(input$colorExplore))

  isTruthy(input$localresetExplore) # adding this statement causes interactive filters to reset,


    if (input$KeepPoliciesTF==TRUE){
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  } else if (input$KeepPoliciesTF==FALSE){
    data=filter.Explore()
  } else {
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  }

  p=par_coords(data=data, n_var=10,
             color_var = input$colorExplore, title='mean-variance', labels=labelsmean.variance, source='mean.variance', policy_ID = Explore_all$ID_constraints, colorbarTitle = input$colorExplore, axes_data=Explore_all$axes, show_ID_front=input$ShowID_Front, labelangle=input$labelangle, titlesize=input$titlesize)
  p=event_register(p,"plotly_restyle")
  p

})


```

### Maximin

```{r, Maximin calcs, include=FALSE}

maximindf=reactiveValues(df=metrics.list_n500$maximin, calcPerc=100, trigger=0) # establish reactive object to store maximin dataframe

observeEvent(input$maximinCalc, {
  
  showNotification('Calculating', type='message', duration=7)
  
  maximindf$df=NULL # reset Hurwicdf
  
  # change the ensemble based on user input
  if (input$SOWensemble=="cLHS n300"){
    obj=dplyr::filter(obj, TraceNumber %in% SOW_id) # filter CRSS objectives output to the 300 SOW
  } else {
    obj=obj_all
  }
  
  df=maximin(data=obj, objectives=colnames(obj)[-c(1,2)], percentile = rep(input$maximinPercentile, 8))
  
  maximindf$df=df # update 

  maximindf$calcPerc=input$maximinPercentile # update percentile of current calculations

  metrics.list$l$maximin=df # update both metrics list. prep$maximin updates because of dependency
  metrics_4app$l$maximin=df

  maximindf$trigger=1
  
  showNotification('Maximin percentile updated', type='message', duration=7)
  
}, ignoreNULL = T, ignoreInit = T)



```


```{r, par coords maximin}

labelsmaximim=colnames(metrics_4app_n500$maximin)


plotlyOutput("pcmaximin")


output$pcmaximin=renderPlotly({
  
  req(isTruthy(Explore_all$df))
  req(isTruthy(input$colorExplore))
  
  isTruthy(input$localresetExplore) # adding this statement causes interactive filters to reset,

  
    if (input$KeepPoliciesTF==TRUE){
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  } else if (input$KeepPoliciesTF==FALSE){
    data=filter.Explore()
  } else {
    data=data.frame(Explore_all$df,global.filter=in_global_filter$y[KS$index])
  }
  
  nvar=if("front" %in% colnames(data)) {10} else {9} # 10 axes if front is included, 9 otherwise
  percentile=isolate(maximindf$calcPerc)
  title=paste0("maximin: ", percentile, "th percentile SOW")
  
  
  p=par_coords(data=data, n_var=nvar, 
             color_var = input$colorExplore, title=title, labels=labelsmaximim, source='maximin', policy_ID = Explore_all$ID_constraints, colorbarTitle = input$colorExplore, axes_data=Explore_all$axes, show_ID_front=input$ShowID_Front, labelangle=input$labelangle, titlesize=input$titlesize)
  p=event_register(p,"plotly_restyle")
  p
  
})


```

Row {.tabset .tabset-fade data-height=275}
------------------------------------------

### Rank of filtered policies for selected metric

```{r, Explore DV plot}

output$Explore_DV=renderPlotly({
  
  # check=dim(filter.Explore())
  # cat(file=stderr(), 'dim=', check, "\n") # prints dimension to R console
  # check=input$xAxisExplore
  # cat(file=stderr(), 'x axis=', check, "\n") # prints dimension to R console

  req(isTruthy(input$xAxisExplore)) # removes temporary error message caused by input$xAxisCustom not rendering until input$apply
  req(input$xAxisExplore %in% colnames(filter.Explore()))
  
  
  if(startsWith(input$xAxisExplore, 'satisficing')){
    max_or_min='max'
  } else {
    max_or_min='min'
  }
  
  req(isTruthy(filter.Explore()))
  req(nrow(filter.Explore())>0)
  req(name$n)
  
  # check=colnames(filter.Explore())
  # cat(file=stderr(), 'cols=', check, "\n") # prints dimension to R console
  # check=min_or_max_Explore$a
  # cat(file=stderr(), 'min or max =', check, "\n") # prints dimension to R console
  
  all_policies=data.frame(metrics_4app$l[[name$n]], add_to_tradeoff)
  
  DV_plot(metric=all_policies, to_plot = filter.Explore()[["ID"]], preferred_direction = max_or_min,
          metric_label = input$xAxisExplore)
  
})

outputOptions(output, name='Explore_DV', priority=-100)
  
plotlyOutput('Explore_DV')

```

### Table of filtered policies

```{r, explore table}

output$Explore_data <- DT::renderDataTable({
  select(filter.Explore(), -starts_with("X"))
}, options = list(scrollY="245px", scrollX="100px", pageLength=10), rownames=FALSE
)

DT::dataTableOutput("Explore_data")

tableSelectExplore=reactiveValues(id=NULL)

observe({
  tableSelectExplore$id=filter.Explore()[['ID']][input$Explore_data_rows_selected]
  a=tableSelectExplore$id-.001
  b=tableSelectExplore$id+.001
  tableSelectExplore$constraints=matrix(c(a,b),ncol=2, byrow = FALSE)})


```




Select your own{data-orientation=rows}
=======================================

Column{.sidebar data-width=235}
--------------------------------


```{r, custom UI}

metric_types=c("",names(metrics_4app_n500)) # add a blank element to beginning. This becomes default, and can be used to fail req()

# update satisficing in metrics_4app and metrics_list
metrics.list.react=reactiveValues(l=metrics.list_n500) # initiliaze
metrics_4app.react=reactiveValues(l=metrics_4app_n500) # initialize

observe({ # this observer will update metrics.list.react$l if the ensemble is changed by user
  metrics.list.react$l=metrics.list$l
  metrics_4app.react$l=metrics_4app$l
})


# metric selection drop down
splitLayout(cellWidths = c(130, 50), h3('Select axes'), circleButton(inputId = "AxesHelp", icon = icon("info-circle"), size = "xs") )

bsTooltip(id = "AxesHelp",title = "Use the drop down menu below to select optimization objectives, robustness metrics, or decision variables to plot in parallel coordinates.", options=list(container="body"), placement = "right" )
dropdownButton(
               
  selectInput("type1", label = "metric 1 type:",
            choices = metric_types),
renderUI({
  req(input$type1)
  selectInput('metric1', 'metric 1:', choices=colnames(metrics.list.react$l[[input$type1]])[-1])
}),

#2
renderUI({
  req(input$metric1)
  selectInput("type2", label = "metric 2 type:",
            choices = metric_types)
}),

renderUI({
  req(input$type2)
  selectInput('metric2', 'metric 2:', choices=colnames(metrics.list.react$l[[input$type2]])[-1])
}),

#3

renderUI({
  req(input$metric2)
  selectInput("type3", label = "metric 3 type:",
            choices = metric_types)
}),

renderUI({
  req(input$type3)
  selectInput('metric3', 'metric 3:', choices=colnames(metrics.list.react$l[[input$type3]])[-1])
}),

#4

renderUI({
  req(input$metric3)
  selectInput("type4", label = "metric 4 type:",
            choices = metric_types)
}),

renderUI({
  req(input$type4)
  selectInput('metric4', 'metric 4:', choices=colnames(metrics.list.react$l[[input$type4]])[-1])
}),

#5

renderUI({
  req(input$metric4)
  selectInput("type5", label = "metric 5 type:",
            choices = metric_types)
}),

renderUI({
  req(input$type5)
  selectInput('metric5', 'metric 5:', choices=colnames(metrics.list.react$l[[input$type5]])[-1])
}),

# 6

renderUI({
  req(input$metric5)
  selectInput("type6", label = "metric 6 type:",
            choices = metric_types)  
}),

renderUI({
  req(input$type6)
  selectInput('metric6', 'metric 6:', choices=colnames(metrics.list.react$l[[input$type6]])[-1])
}),

#7 
renderUI({
  req(input$metric6)
  selectInput("type7", label = "metric 7 type:",
            choices = metric_types)  
}),
renderUI({
  req(input$type7)
  selectInput('metric7', 'metric 7:', choices=colnames(metrics.list.react$l[[input$type7]])[-1])
}),

#8
renderUI({
  req(input$metric7)
  selectInput("type8", label = "metric 8 type:",
            choices = metric_types)  
}),
renderUI({
  req(input$type8)
  selectInput('metric8', 'metric 8:', choices=colnames(metrics.list.react$l[[input$type8]])[-1])
}),
#9
renderUI({
  req(input$metric8)
  selectInput("type9", label = "metric 9 type:",
            choices = metric_types)  
}),
renderUI({
  req(input$type9)
  selectInput('metric9', 'metric 9:', choices=colnames(metrics.list.react$l[[input$type9]])[-1])
}),

#10
renderUI({
  req(input$metric9)
  selectInput("type10", label = "metric 10 type:",
            choices = metric_types)  
}),
renderUI({
  req(input$type10)
  selectInput('metric10', 'metric 10:', choices=colnames(metrics.list.react$l[[input$type10]])[-1])
}),
#11
renderUI({
  req(input$metric10)
  selectInput("type11", label = "metric 11 type:",
            choices = metric_types)  
}),
renderUI({
  req(input$type11)
  selectInput('metric11', 'metric 11:', choices=colnames(metrics.list.react$l[[input$type11]])[-1])
}),

#12
renderUI({
  req(input$metric11)
  selectInput("type12", label = "metric 12 type:",
            choices = metric_types)  
}),
renderUI({
  req(input$type12)
  selectInput('metric12', 'metric 12:', choices=colnames(metrics.list.react$l[[input$type12]])[-1])
}),



actionButton('apply', 'apply selected metrics'),


width=220, label='select metrics', circle = F
  
  
)

div(style="margin-bottom:5px") # adds padding between buttons


############# filter selection dropdown

custom_options=reactive({
  cols=colnames(prep_custom.df()) # -1 to remove ID as option
  cols=cols[which(startsWith(cols, 'X')==FALSE)]
  all=c('None', cols)
  all
  })

splitLayout(cellWidths = c(130, 50), h3('Local filters'), circleButton(inputId = "LFHelpCustom", icon = icon("info-circle"), size = "xs") )

bsTooltip(id = "LFHelpCustom",title = "Local filters are saved only to the current page. To save these filters and apply additional filters on other pages, select Save Filters Globally.", options=list(container="body"), placement = "right" )


dropdownButton(label='manual filters', circle = F, width = 220,
               
renderUI({
  req(input$apply)
  selectInput("VarCustom1", label = "Filter 1:",
            choices = custom_options(), selected = 'None')
}),

renderUI({
    req(input$apply)
    selectInput("IneqCustom1", label = "Inequality 1:",
            choices = c('<', '>'), selected = '<')
}),

renderUI({
  req(input$apply)
  textInput('ThreshCustom1', label= 'Threshold 1:', value='', placeholder='10')

}),

renderUI({
  req(input$apply)
  selectInput("VarCustom2", label = "Filter 2:",
            choices = custom_options(), selected = 'None')
}),

renderUI({
      req(input$apply)
    selectInput("IneqCustom2", label = "Inequality 2:",
            choices = c('<', '>'), selected = '<')
  
}),

renderUI({
    req(input$apply)
  textInput('ThreshCustom2', label= 'Threshold 2:', value='', placeholder='10')

}),

renderUI({
  req(input$apply)
  selectInput("VarCustom3", label = "Filter 3:",
            choices = custom_options(), selected = 'None')
}),

renderUI({
      req(input$apply)
    selectInput("IneqCustom3", label = "Inequality 3:",
            choices = c('<', '>'), selected = '<')
  
}),

renderUI({
    req(input$apply)
  textInput('ThreshCustom3', label= 'Threshold 3:', value='', placeholder='10')

}),

renderUI({
  req(input$apply)
  textInput("IDCustom", label='Select policy IDs', placeholder='eg: 292,54')
}),

renderUI({
  req(input$apply)
  actionButton('manualfilterCustom', 'save manual filters', width = 190)
})

)

div(style="margin-bottom:5px") # adds padding between buttons

renderUI({
  req(input$apply)
  actionButton('brushfilterCustom',label='save brush filters', width = 190)

})

h4("table selections:", align="center")

renderUI({
  req(name$n)
  
  fluidRow(column(width=3,
    actionButton('tableKeepCustom',label='keep', width=91)),
    column(width=3, offset=2,
    actionButton("tableRemoveCustom", label="remove", width=93))
    )

})

div(style="margin-bottom:5px") # adds padding between buttons

renderUI({
  req(input$apply)
  actionButton('localresetCustom',label='reset local filters', width = 190)

})
div(style="margin-bottom:20px") # adds padding between buttons

splitLayout(cellWidths = c(150, 50), h3('Global filters'), circleButton(inputId = "GFHelpCustom", icon = icon("info-circle"), size = "xs") )

bsTooltip(id = "GFHelpCustom",title = "Global filters are honored on other pages. For example, filter policies by thresholds in Optimization objectives, save globally, then apply additional filters on the Robustness metrics page.", options=list(container="body"), placement = "right" )

renderUI({
  req(input$apply)
  actionButton('global_filterCustom', label='save filters globally', width = 190)
})
div(style="margin-bottom:5px") # adds padding between buttons

renderUI({
  req(input$apply)
  actionButton('resetCustom',label='reset global filters', width = 190)
})

div(style="margin-bottom:5px") # adds padding between buttons

h3('Plot variables')

renderUI({
  req(input$apply)
  actionButton('addFront', label='Calculate fronts', width = 190)
})

div(style="margin-bottom:5px") # adds padding between buttons

renderUI({
  req(input$apply)
  selectInput('colorCustom', label='ParCoords color variable', choices=c(custom_options()[-1], 'global.filter', 'front'), selected = custom_options()[1], width = 190)

})

renderUI({
  req(input$apply)
  selectInput('xAxisCustom', label = 'Metric for ranking', choices=custom_options()[-1], selected=custom_options()[1], width = 190)
})

splitLayout(cellWidths = c(150,50), 
        
  downloadHandler(filename="Custom filtered policies.xlsx", content=function(file) {

  # remove empty rows in the log objects
  data=filterLog$global
  global=data[rowSums(is.na(data)) != ncol(data),]
  data=logCustom$log
  local=data[rowSums(is.na(data)) != ncol(data),]

  temp=select(filter.Custom(), -starts_with("X"))
  cat(file=stderr(), 'your name:', colnames(temp), "\n") # prints dimension to R console
  df=dplyr::filter(temp, ID %in% KS$index)
  
  
  data.list=list("policies"=df, "global.filters"=global, "local.filters"=local)
  write.xlsx(data.list, file)
  
    }),
    
  circleButton(inputId= "settingsCustom", icon=icon("chart-line"), status = "primary")
  
            )

bsTooltip(id="settingsCustom",title="global plot settings", options=list(container="body"), placement = "right")

observeEvent(input$settingsCustom, {modalTrigger$Custom=1+modalTrigger$Custom}, ignoreInit = T)


```


```{r, process Custom UI, include=FALSE}

# create custom dataframe
prep_custom.df=eventReactive(eventExpr={input$apply| input$addFront | reset$SOWchange > 0},{
  

  for (i in 1:13){ # loop through user input, determine number of metrics
    if (!isTruthy(input[[paste0('metric',(i))]])){
      break
    }
    cols=i+1
  }

  df=data.frame(matrix(nrow=nrow(wide_data), ncol=cols))
  df[,1]=wide_data$ID
  colnames(df)[1]='ID'
  for(i in 2:13){
    
    if (isTruthy(input[[paste0('metric',(i-1))]])){ # have to check if input was given. If not, error!
        
        type=input[[paste0('type',(i-1))]] # metric type (ie, regret2, LaplacePIR)
        name=input[[paste0('metric',(i-1))]] # metric name
        df[,i]=metrics.list.react$l[[type]][[name]]

        if (name %in% colnames(df)){ # check if column name alread exists
          colnames(df)[i]=paste(type,'.',name, sep='')
          first_i=which(colnames(df) == name)
          colnames(df)[first_i]=paste(input[[paste0('type',first_i-1)]], '.', name, sep='')
        } else { # I opted to label every axis with type.metric, even if metric not already used. Simpler this way
          colnames(df)[i]=paste(type,'.',name, sep = '')
        }
          
    }
    
    df=data.frame(df[,1:cols], add_to_tradeoff)
  }
  reset$SOWchange=0
  
  df
}, ignoreNULL = T, ignoreInit = T)


custom.df=reactive({dplyr::filter(prep_custom.df(), ID %in% global_filter$r)})

#### initialize with all 463 policies
policiesIDCustom=reactiveValues(r=1:nrow(wide_data))
manualIDCustom=reactiveValues(r=1:nrow(wide_data))
interactiveIDCustom=reactiveValues(r=1:nrow(wide_data))

logCustom=reactiveValues(log=df.initialize)

#### calculate non dominated front on user input ####

front.Custom=reactiveValues(f=rep(1,nrow(wide_data))) # initialize as ones

observeEvent(input$addFront,{
  
  withProgress(message='Calculating fronts', value=0, {
      front.Custom$f=calc_NonDom_front(data=prep_custom.df()[,1:nvar()], max_cols = max_id())
      incProgress(amount=0.75)
  })
  
}, priority = 100)


#### update manualIDCustom based on user input

observeEvent(input$manualfilterCustom, {
  temp=manual_filters(ID_key='IDCustom', unique_thresh_ID = 'Custom',dataframe = custom.df(), page="Custom")
  manualIDCustom$r=temp[[1]]
  
  logCustom$log=rbind(logCustom$log, temp[[2]])
})

#### update interactiveIDCustom based on par coords brushing
rangesCustom <- reactiveValues(a=list())
#### get ranges from brushing

observeEvent(eventExpr = event_data("plotly_restyle", source = "pcoordsCustom"),{

  df=data.frame(prep_custom.df()[,1:nvar()],front=front.Custom$f)

  temp=get_brush_ranges(source = "pcoordsCustom", prep_df = df)
    if (is.na(temp)){
    # do nothing
  } else {
     rangesCustom$a[[temp[[1]]]]=temp[[2]]
     
  }
  
})

#### get policies from brushing
observeEvent(input$brushfilterCustom,{

  
  df=data.frame(prep_custom.df()[,1:nvar()],front=front.Custom$f)

  temp=get_brush_policyID(ranges=rangesCustom$a, prep_df = df, page="Custom")
  
  interactiveIDCustom$r=temp[[1]]
   
  logCustom$log=rbind(logCustom$log, temp[[2]])
})

### update policiesIDCustom as intersection of global filter, manual filter, and interactive filter

observe({
  a=intersect(manualIDCustom$r, interactiveIDCustom$r)
  b=intersect(a, global_filter$r)
  policiesIDCustom$r=b
}
)

### update policiesIDCustom based on table selections

observeEvent(input$tableKeepCustom, {
  
  policiesIDCustom$r=intersect(policiesIDCustom$r, tableSelectCustom$id)
  
  add_vec=c("Custom", "ID", "table select", NA, NA, paste(as.character(tableSelectCustom$id), collapse=","))
  temp=df.initialize
  temp[1,]=add_vec
  logCustom$log=rbind(logCustom$log, temp)
  
}, ignoreInit = T)

observeEvent(input$tableRemoveCustom, {
  
  all=1:nrow(wide_data)
  subset=all[-tableSelectCustom$id]
  
  policiesIDCustom$r=intersect(policiesIDCustom$r, subset)
  
  add_vec=c("Custom", "ID", "table remove", NA, NA, paste(as.character(tableSelectCustom$id), collapse=","))
  temp=df.initialize
  temp[1,]=add_vec
  logCustom$log=rbind(logCustom$log, temp)
  
}, ignoreInit = T)

### establish filter.custom

filter.Custom=reactive({ # because Custom() already accounts for global filter, filter.Custom is intersection of global and local POLICY ID filter only
  validate(need(input$apply, 'Select robustness metrics'))
  dplyr::filter(custom.df(), ID %in% policiesIDCustom$r)
  
})

### apply global filter

observeEvent(input$global_filterCustom, {
  
  temp=intersect(policiesIDCustom$r, KS$index)
  global_filter$r=intersect(global_filter$r, temp )
  
  remaining=length(global_filter$r)
  showNotification(paste(remaining, 'policies remain in global filter', sep=' ' ), type='message', duration=7)
  
  filterLog$global=rbind(filterLog$global, logCustom$log)
})


### local reset button

observeEvent(input$localresetCustom, {
  policiesIDCustom$r=1:nrow(wide_data)
  manualIDCustom$r=1:nrow(wide_data)
  interactiveIDCustom$r=1:nrow(wide_data)
  tableSelectCustom$id=NULL
  rangesCustom$a=NULL
  logCustom$log=df.initialize
})

# also, if color changes, reset local filters

observeEvent(input$colorCustom,{

  interactiveIDCustom$r=1:nrow(wide_data)
  rangesCustom$a=NULL
  
  rows=which(logCustom$log$filter.type=="brush")
  logCustom$log=logCustom$log[-rows,]
})



```

Row {data-height=325}
-----------------------
### Parallel coordinates

```{r, custom parallel coordinates}

includeFront=reactiveValues(Bin=0)

observeEvent(input$addFront, { # indicate of front axis is added to PC plot
  includeFront$Bin=1
})

observeEvent(reset$SOWchange>0, { # remove front from PC if SOW ensemble changes
  includeFront$Bin=0
})

observeEvent(input$apply, { # remove front form PC if user changes PC plot dimensions
  includeFront$Bin=0
})

nvar=reactive({
  
  for (i in 1:13){ # loop through user input, determine number of metrics
    if (!isTruthy(input[[paste0('metric',(i))]])){
      break
    }
    cols=i+1
    }
  cols
})

max_id=reactive({
  both=startsWith(colnames(prep_custom.df()), 'satisficing.sat.') # this includes both sat. and sat.dev.
  sat.dev=startsWith(colnames(prep_custom.df()), 'satisficing.sat.dev.')

  which((both+sat.dev)==1)
  
  # both=startsWith(test_names, 'satisficing.sat.') # this includes both sat. and sat.dev.
  # sat.dev=startsWith(test_names, 'satisficing.sat.dev.')
  # 
  # which((both+sat.dev)==1)
  
  
})


plotlyOutput("pcCustom")

color_custom=reactiveValues() #initiate container for custom color variables initiation

output$pcCustom=renderPlotly({
  
  input$KeepPoliciesTF # this causes plot to rerender if user changes options from keeping filtered policies to removing them or vise versa
  
  validate(need(input$apply, 'Select robustness metrics'))
  isTruthy(input$localresetCustom)

  
  
  # silent error occurs if I don't provide a default value for color_var. This happens because ParCoords Col Var hasn't initiated until filter policies is opened
  
  if (isTruthy(input$colorCustom)){
    color_custom$c=input$colorCustom
  } else {
    color_custom$c="ID"
  }
  
  

    ## create matrix of policy ID constraints that considers both the global filter plus table selections
  bind=rbind(tableSelectCustom$constraints, global_filter$constraints) # bind table and global filter matrices
  
  if(TRUE %in% duplicated(bind)){ # check if any duplicate rows. If so, then the user has selected data in the table and only that should be highlighted
    ID_constraints=bind[duplicated(bind),]
  } else {
    ID_constraints=global_filter$constraints # if no duplicates, then color only policies in global filter
  }

  

  if (includeFront$Bin>0){
    
    axes_data=data.frame(prep_custom.df()[,1:nvar()],front=front.Custom$f, prep_custom.df()[,(nvar()+1):ncol(prep_custom.df())] ,global.filter=in_global_filter$y)
    
    if (input$KeepPoliciesTF==TRUE){
    temp=data.frame(prep_custom.df()[,1:nvar()],front=front.Custom$f, prep_custom.df()[,(nvar()+1):ncol(prep_custom.df())] ,global.filter=in_global_filter$y)
    data=dplyr::filter(temp, ID %in% KS$index)
    } else if (input$KeepPoliciesTF==FALSE){
    temp=data.frame(filter.Custom()[,1:nvar()],front=front.Custom$f[filter.Custom()[['ID']]], filter.Custom()[,(nvar()+1):ncol(filter.Custom())])
    data=dplyr::filter(temp, ID %in% KS$index)
    } else {
    temp=data.frame(prep_custom.df()[,1:nvar()],front=front.Custom$f, prep_custom.df()[,(nvar()+1):ncol(prep_custom.df())] ,global.filter=in_global_filter$y)
    data=dplyr::filter(temp, ID %in% KS$index)
    }
    
    
          custom=par_coords(data=data, n_var=nvar()+1, color_var = color_custom$c, title='user selected metrics', max_cols = max_id(), source='pcoordsCustom', policy_ID = ID_constraints, colorbarTitle = color_custom$c, axes_data=axes_data, show_ID_front=input$ShowID_Front)


  } else {
    
    axes_data=data.frame(prep_custom.df(),global.filter=in_global_filter$y)
    
      if (input$KeepPoliciesTF==TRUE){
    temp=data.frame(prep_custom.df(),global.filter=in_global_filter$y)
    data=dplyr::filter(temp, ID %in% KS$index)
    } else if (input$KeepPoliciesTF==FALSE){
    data=dplyr::filter(filter.Custom(), ID %in% KS$index)
    } else {
    temp=data.frame(prep_custom.df(),global.filter=in_global_filter$y)
    data=dplyr::filter(temp, ID %in% KS$index)
    }
    # colnames=colnames(data)
    # n_var=nvar()
    # cat(file=stderr(), 'custom columns:', colnames, "\n") # prints dimension to R console
    # 
    custom=par_coords(data=data, n_var=nvar(), color_var = color_custom$c, title='user selected metrics', max_cols = max_id(),
             source='pcoordsCustom', policy_ID = ID_constraints, colorbarTitle = color_custom$c, axes_data=axes_data, show_ID_front=input$ShowID_Front)
  }
  

  custom=event_register(custom, "plotly_restyle")
  custom
  
})

```

Row {.tabset .tabset-fade data-height=275}
-------------------------------------------

### Rank of filtered policies for selected metric

```{r, Custom DV plot}

min_or_max_cust=reactive({
  
  if (startsWith(input$xAxisCustom, 'satisficing.satisficing')){
    'max'
  }else {
    'min'
  }
  
})

renderPlotly({
  req(input$xAxisCustom) # removes temporary error message caused by input$xAxisCustom not rendering until input$apply
  DV_plot(metric=prep_custom.df(), to_plot = intersect(filter.Custom()[["ID"]], KS$index) , preferred_direction = min_or_max_cust(),
          metric_label = input$xAxisCustom)
  
})

# 

```

### Table of filtered policies

```{r, Custom table}

output$Custom_data <- DT::renderDataTable({
  input$localresetCustom
  temp=select(filter.Custom(), -starts_with("X"))
  dplyr::filter(temp, ID %in% KS$index)
}, options = list(scrollY="245px", scrollX="100px", pageLength=10), rownames=FALSE
)

DT::dataTableOutput("Custom_data")

tableSelectCustom=reactiveValues(id=NULL)

observe({
  
  data=dplyr::filter(filter.Explore(), ID %in% KS$index)

  tableSelectCustom$id=data[['ID']][input$Custom_data_rows_selected]
  a=tableSelectCustom$id-.001
  b=tableSelectCustom$id+.001
  tableSelectCustom$constraints=matrix(c(a,b),ncol=2, byrow = FALSE)

})

```


SOW ensemble rank correlation {data-navmenu="Sensitivity analysis" data-orientation=rows}
========================================

Column{.sidebar data-width=225}
--------------------------------

```{r, rank cor UI}
splitLayout(cellWidths = c(70, 50), h3("x axis"), circleButton(inputId = "SOWSensHelp", icon = icon("info-circle"), size = "xs") )

bsTooltip(id="SOWSensHelp", title="Compare the ranking of policies for different SOW ensembles and/or different classes of robustness metrics. The heat map shows the rank correlation of policies for the selected SOW ensemble and metrics. A value of 1 means the ranking of policies is identical, whereas -1 means the ranking is reversed. For details, please see McPhail et al. 2021, Impact of Scenario Selection on Robustness.", placement = "right", options=list(container="body") )

selectInput('SOW1x', label='SOW ensemble', selected='cLHS n500', choices=c('cLHS n500', 'cLHS n300'))


SOW=reactiveValues()
observeEvent(input$SOW1x,{
  SOW$x=if(input$SOW1x=='cLHS n500'){metrics.list_n500} else if (input$SOW1x=='cLHS n300'){metrics.list_n300} else {metrics.list_n500}
})

renderUI({

  req(input$SOW1x)

  selectInput('CorTypex','metric type', choices=names(SOW$x), selected=names(SOW$x)[1])

})


h3("y axis")

selectInput('SOW1y', label='SOW ensemble', selected='cLHS n300', choices=c('cLHS n500', 'cLHS n300'))

observeEvent(input$SOW1y,{
  SOW$y=if(input$SOW1y=='cLHS n500'){metrics.list_n500} else if (input$SOW1y=='cLHS n300'){metrics.list_n300} else {metrics.list_n500}
})

renderUI({

  req(input$SOW1y)
  selectInput('CorTypey','metric type', choices=names(SOW$y), selected=names(SOW$y)[1])

})


```

Row
-----------------------------------------

### SOW ensemble correlation

```{r}

rankCor=reactive({

  req(input$CorTypex)
  req(input$CorTypey)

  
  x=SOW$x[[input$CorTypex]][-1]
  y=SOW$y[[input$CorTypey]][-1]

  x_rank=data.frame(matrix(nrow=nrow(x), ncol=ncol(x)))
  colnames(x_rank)=colnames(x)

  for(i in 1:ncol(x)){
    correction=ifelse(startsWith(colnames(x)[i], 'satisficing'),-1,1)
    x_rank[,i]=rank(correction*x[,i])
  
  }

  y_rank=data.frame(matrix(nrow=nrow(y), ncol=ncol(y)))
  colnames(y_rank)=colnames(y)

  for(i in 1:ncol(y)){
   correction=ifelse(startsWith(colnames(y)[i], 'satisficing'),-1,1)
   y_rank[,i]=rank(correction*y[,i])
    
  }


  cor.df=data.frame(matrix(nrow=ncol(x)*ncol(y), ncol=3))
  colnames(cor.df)=c('x', 'y', 'rank.cor')

  c=1
  for (yi in 1:ncol(y)){# loop through y variables
  
    y_temp=y_rank[,yi]
  
    for (xi in 1:ncol(x)){# loop through x variables
    
      x_temp=x_rank[,xi]
    
    # cor=Kendall(x,y)$tau
    
      cor.df$y[c]=colnames(y_rank)[yi]
      cor.df$x[c]=colnames(x_rank)[xi]
      cor.df$rank.cor[c]=Kendall(x_temp,y_temp)$tau
    
      c=c+1
    
    }
  
  }
  cor.df
})

renderPlotly({
  
  req(nrow(rankCor())>0)
  
  x=rankCor()[['x']]
  y=rankCor()[['y']]
  z=rankCor()[["rank.cor"]]

  axis=function(name){
    return(list(title=name))
  }
  
  fig=plot_ly(type='heatmap', colorscale = "Portland",
             
             x=x, y=y, z=z, xgap=3, ygap=3
             
             
  ) %>% layout(xaxis=axis(input$SOW1x), yaxis=axis(input$SOW1y), title='Kendall Tau rank correlation', margin=list(l=50,r=40,b=60,t=40,   pad=0))

  fig=colorbar(fig, limits=c(-1.05,1.05))
  fig
  
})


```

Satisficing thresholds for selected policy(s) {data-navmenu="Sensitivity analysis" data-orientation=rows}
========================================

Column {.sidebar data-width=325}
-------------------------------------

```{r, satisficing thresholds select policies UI}

splitLayout(cellWidths = c(240,30),div(style="margin-bottom:30px"),
            circleButton(inputId = "SatisSensHelp", icon = icon("info-circle"), size = "xs")) # adds padding between buttons

bsTooltip(id="SatisSensHelp", title="Assess the sensitivity of satisficing fraction to the user-defined performance thresholds. Use the dropdown buttons below to select policies, performance objectives, and threshold ranges over which the satisficing fraction is calculated. For example, you can use the first dropdown button to calculate satisficing fraction for performance thresholds ranging from 0 to 20% on M1000 and P3490 for policy 1. You will obtain both a heatmap and decision variable plot in the left column. Then, use the second dropdown button to change the objectives, threshold ranges, and/or policies, and the results will be plotted in the right column.", placement = "right", options=list(container="body") )

dropdownButton(circle=FALSE, label = "Select your own objectives (1)", width="300px",
                h4("Select policy(s)"), 
        
        selectInput(inputId="SensID1", label=NULL,choices=1:463, selected=NULL, multiple=T),
        
        h4("Objective 1"),
        
        selectInput(inputId = "SensX1", label=NULL, choices=colnames(obj_all)[-c(1:2)], selected=colnames(obj_all)[3]),
        
        renderUI({
          
          req(isTruthy(input$SensX1))
          
          sliderInput(inputId = "SensXrange1", label=paste0(input$SensX1, " range"), min=min(obj_all[[input$SensX1]]),
                max=max(obj_all[[input$SensX1]]), value=c(0,median(obj_all[[input$SensX1]])), width=260)
          
        }),
        
        
        h4("Objective 2"),
        
        selectInput(inputId = "SensY1", label=NULL, choices=colnames(obj_all)[-c(1:2)], selected=colnames(obj_all)[3]),
        
        renderUI({
          
          req(isTruthy(input$SensY1))
          
          sliderInput(inputId = "SensYrange1", label=paste0(input$SensY1, " range"), min=min(obj_all[[input$SensY1]]),
                max=max(obj_all[[input$SensY1]]), value=c(0,median(obj_all[[input$SensY1]])), width=260)
          
        }),
        
       
        actionButton(inputId = "SensCalcs1", label="Calculate"))

div(style="margin-bottom:30px") # adds padding between buttons


dropdownButton(circle=FALSE, label = "Select your own objectives (2)", width="300px",
                
        h4("Select policy(s)"), 
        
        selectInput(inputId="SensID2", label=NULL,choices=1:463, selected=NULL, multiple=T),
        
        h4("Objective 2"),
        
        selectInput(inputId = "SensX2", label=NULL, choices=colnames(obj_all)[-c(1:2)], selected=colnames(obj_all)[3]),
        
        renderUI({
          
          req(isTruthy(input$SensX2))
          
          sliderInput(inputId = "SensXrange2", label=paste0(input$SensX2, " range"), min=min(obj_all[[input$SensX2]]),
                max=max(obj_all[[input$SensX2]]), value=c(0,median(obj_all[[input$SensX2]])), width=260)
          
        }),
        
        
        h4("Objective 2"),
        
        selectInput(inputId = "SensY2", label=NULL, choices=colnames(obj_all)[-c(1:2)], selected=colnames(obj_all)[3]),
        
        renderUI({
          
          req(isTruthy(input$SensY2))
          
          sliderInput(inputId = "SensYrange2", label=paste0(input$SensY2, " range"), min=min(obj_all[[input$SensY2]]),
                max=max(obj_all[[input$SensY2]]), value=c(0,median(obj_all[[input$SensY2]])), width=260)
          
        }),
        
       
        actionButton(inputId = "SensCalcs2", label="Calculate"))

div(style= "margin-bottom: 20px")

prettyToggle("ObjTable", label_on = "Show table of objectives", label_off = "Hide table of objectives", bigger = T)

obj_table=read.csv(file="objectives summary table FOR APP.csv", colClasses = c("character", "character", "character"))
 
conditionalPanel("input.ObjTable == true",
                 
       renderTable({obj_table}, striped=T, hover=T, bordered=T, width="300px")          
                 
                 )


```


Row {data-height=750}
-----------------------------------

### Select your own objectives (1)

```{r, calculate sensitivity 1}

sensitivity_plots=reactiveValues()

observeEvent(input$SensCalcs1, {
  
  showNotification("Calculating and plotting" )
  
  fig=satisficing_sensitivity(data=obj_all, n=40, policy_IDs = input$SensID1, obj1=input$SensX1, range1= input$SensXrange1, obj2 = input$SensY1, range2 = input$SensYrange1)
  
  sensitivity_plots$SYO1=fig
  
  showNotification("Calculation complete. See 'Select your own objectives (1)' for results." )
  
}, ignoreInit = T, ignoreNULL = T)

```

```{r, plot sensitivity plot 1}

renderPlotly({
  
  req(isTruthy(sensitivity_plots$SYO1))
    sensitivity_plots$SYO1
    
})

```


### Select your own objectives (2)

```{r, calculate sensitivity 2}

sensitivity_plots=reactiveValues()

observeEvent(input$SensCalcs2, {
  
  showNotification("Calculating and plotting" )
  
  fig=satisficing_sensitivity(data=obj_all, n=40, policy_IDs = input$SensID2, obj1=input$SensX2, range1= input$SensXrange2, obj2 = input$SensY2, range2 = input$SensYrange2)
  
  sensitivity_plots$SYO2=fig
  
  showNotification("Calculation complete. See 'Select your own objectives (2)' for results." )
  
}, ignoreInit = T, ignoreNULL = T)

```

```{r, plot sensitivity plot 2}

renderPlotly({
  
  req(isTruthy(sensitivity_plots$SYO2))
    sensitivity_plots$SYO2
    
})

```

Row
---------------------------

### Policy(s) decision variables (1)

```{r, sensitivity DV plot (1)}

renderPlotly({
  
  DV_plot(metric=prep$optimization, to_plot=input$SensID1, metric_label="ID", preferred_direction="min", y_axis2=F)
  
})

```

### Policy(s) decision variables (2)

```{r, sensitivity DV plot (2)}

renderPlotly({
  
  DV_plot(metric=prep$optimization, to_plot=input$SensID2, metric_label="ID", preferred_direction="min", y_axis2=F)
  
})

```















